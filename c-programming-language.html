<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-139237428-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-139237428-1');
</script>
<link rel="stylesheet" type="text/css" href="style.css">
<meta name="viewport" content="width=device-width">
<link rel="icon" href="data:,">
<title>The C Programming Language (Kernighan & Ritchie)</title>
</head>


<body>

<nav><a href="/">home</a></nav>

<header>
<h1>The C Programming Language (Kernighan & Ritchie)</h1>
</header>


<main>
<h2 id="1-a-tutorial-introduction">1 - A TUTORIAL INTRODUCTION</h2>
<h3 id="1-1-getting-started">1.1 Getting Started</h3>
<p>C program consists of functions and variables. Function contains statements that specify operations, and variables store values. Program begins executing at main so every program must have a <code>main()</code> function.</p>
<h3 id="1-2-variables-and-arithmetic-exceptions">1.2 Variables and Arithmetic Exceptions</h3>
<p><code>/* Comment */</code>
All variables must be declared before they are used. Common data types are int, float, char, short, long, double. While loops are notated by <code>while ( )</code>. Inside a printf statement a % indicates where an arguments is to be substituted <code>printf(&quot;%d %3.2f\n&quot;, fahr, celsius);</code> substitutes fahr into the %d location, and celsius is a float number with two numbers after decimal point, and a space location of at least 3 characters wide.</p>
<h3 id="1-3-the-for-statement">1.3 The for statement</h3>
<p>For loop has similar notation <code>for (fahr=0; fahr &lt;= 300; fahr = fahr + 20)</code>.</p>
<h3 id="1-4-symbolic-constants">1.4 Symbolic Constants</h3>
<p>A define line defines a symbolic name or symbolic constant for a string of characters <code>#define LOWER 0</code>. After this define line, every occurence of LOWER will be replaced with 0 in the program. Symbolic names are conventionally written in upper case letters to distinguish from variable names. There is no semi colon at the end of the define line.</p>
<h3 id="1-5-character-input-and-output">1.5 Character Input and Output</h3>
<p>Text stream is a sequence of characters divided into lines by new line characters. getchar reads the next input character from a text stream every time it is called <code>c = getchar();</code>. <code>putchar</code> prints a character each time called <code>putchar(c);</code>. <code>++variable</code> or <code>variable++</code> can be used to increment a variable. A for or while loop must have a body, so we use an indented semicolon as a null statement <code>\t;</code>. To check for equality == and != is used. These are different form = which is used for assignment statements. A Character written in single quotes represent an integer value -&gt; &#39;A&#39; has a ASCII value of 65. And is written as &amp;&amp; and or is written as ||. Also conditional statements are written in form: </p>
<pre><code><span class="hljs-keyword">if</span> ( ); 
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ); 
<span class="hljs-keyword">else</span>;
</code></pre><h3 id="1-6-arrays">1.6 Arrays</h3>
<p>Declaring an array <code>int ndigit[10];</code>. This creates an array of 10 elements. Accessing these array values start at 0 and end at 9 for this example <code>ndigit[0]</code>. </p>
<h3 id="1-7-functions">1.7 Functions</h3>
<p>Properly designed functions remove to need to know how a job is done; knowing what is done can be sufficient for the output. Function definition has form:</p>
<pre><code><span class="hljs-keyword">return</span>-<span class="hljs-keyword">type</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span>-<span class="hljs-keyword">name</span>(<span class="hljs-keyword">parameter</span> declarations)
{
declarations
statements
}
</code></pre><p>Variables inside a function are local, reusing their name outside the scope doesn&#39;t cause a conflict. Usually every function should return a value, even the main function. The notation for returning is <code>return 0;</code>. Returning 0 usually implies a normal termination. Functions use a function prototype, which is written before the main function in the form <code>int power (int, int);</code>. The parameters don&#39;t have to be named, but they&#39;re data types have to be signified. </p>
<h3 id="1-8-arguments-call-by-value">1.8 Arguments - Call by Value</h3>
<p>All functions arguments are passed by values, they are temporary variables rather than the originals. Parameters are local initialized variables in the called routine.</p>
<h3 id="1-9-character-arrays">1.9 Character Arrays</h3>
<p>A function that doesn&#39;t return a value is set to return type &quot;void&quot;. The &quot;\0&quot; character marks the termination of a string. Must add this at the end of a char array if you want to be able to print out this array.</p>
<h3 id="1-10-external-variables-and-scope">1.10 External Variables and Scope</h3>
<p>Each local variable in a function only comes into existence once that function is called, and disappears when the function is exited. These variables are also called automatic variables. They do not retain their value with each function call, hence they have to set with each entry. External variables are declared outside the main function, and are globally accessible. They also exist permanently. The global variable&#39;s try has to be declared inside a function however <code>extern int max;</code>. The extern label isn&#39;t needed if the external variables are declared at the beginning of the source file.</p>
<p>Definition is where variable is created or assigned storage. Declaration is where variable is stated, but no storage allocated. </p>
<h2 id="2-types-operators-and-expressions">2 - TYPES, OPERATORS AND EXPRESSIONS</h2>
<h3 id="2-1-variable-names">2.1 Variable Names</h3>
<p>Variables names must start with letter and can include letters, digits and underscores. Use underscores to make long variable names more readable. Use short names for local variables (i.e. loop indices) and long names for external variables.</p>
<h3 id="2-2-data-types-and-sizes">2.2 Data Types and Sizes</h3>
<p>Basic data types in C:</p>
<ul>
<li>char - single byte holds character; </li>
<li>int - integer that reflects natural size of integers on host machine; </li>
<li>float - single precision floating point; </li>
<li>double - double precision floating point. </li>
</ul>
<p>Qualifiers &#39;signed&#39; or &#39;unsigned&#39; can be added to char or any integer. Unsigned numbers are always positive or zero and go to 2^n. Signed chars can be negative or positive and go from 2^(n-1) to 2^(n-1) - 1. Standard headers <code>&lt;limits.h&gt;</code> and <code>&lt;float.h&gt;</code> contain symbolic constants for these sizes.</p>
<h3 id="2-3-constants">2.3 Constants</h3>
<p>A long constant has to be written with a terminal l or L <code>123556789L</code>. Unsigned constants end with terminal u or U and unsigned long end with ul or UL <code>1234u or 123456978ul</code>. Floating point constant contain decimal point (123.4), exponents (1e-2) and end with suffix f or F. Integer can be specified as octal or hexadecimal with a leading 0 (octal) or a leding 0x or 0X (hexadecimal). Character constants are written in single quotes and are evaluated based on ASCII value -&gt; &#39;0&#39; is equal to 48 in ASCII. </p>
<p>String constants are enclosed in double quotes <code>&quot;Hello world.&quot;</code>. Constant expressions are evaluated at run time <code>#define SIZE 1000</code>. String constant have to end with a &#39;\0&#39;. <code>strlen(s)</code> in <string.h> returns the length of the string without taking into account &#39;\0&#39;. Enumeration constant is a list of constant integer values <code>enum boolean { NO, YES };</code>. The first value in enum has value 0, the next 1, the next 2 and so on. Values in enum can also be assigned names <code>enum months { JAN = 1; FEB, MAR, APR ... }</code>. </p>
<h3 id="2-4-declarations">2.4 Declarations</h3>
<p>Variables and their types must be declared before use. Qualifier <code>const</code> can be added to signify that a value won&#39;t change <code>const double e 2.71828182845905;</code>. Const can also be used with array so that they don&#39;t change.</p>
<h3 id="2-5-arithmetic-operators">2.5 Arithmetic Operators</h3>
<p>Standard binary arithmetic operators +, -, <em>, / and %. Integer division truncates fractions. Modulo operator % can&#39;t be applied to a float or double. </em>, / and % have higher precedence than + and -. Operators associate left to right.</p>
<h3 id="2-6-relational-and-logical-operators">2.6 Relational and Logical Operators</h3>
<p>Standard relational operators &gt;, &gt;=, &lt;, &lt;= have higher precedence than equality operators == and !=. Relational operators have lower precendence than arithmetic operators. Logical operators &amp;&amp; (and) and || (or) are evaluated left to right and evaluation stops as soon as result is known. For example <code>i &lt; SIZE &amp;&amp; (c=getchar()) != &#39;\n&#39;</code> checks if there is space in array first before getting another character. &amp;&amp; has higher precendence than ||.</p>
<h3 id="2-7-type-conversions">2.7 Type Conversions</h3>
<p>Automatic conversions occur when narrower information is converted to wider information without losing information <code>float + int = int</code>. Expressions that lose information (long int to short) draw a warning but aren&#39;t illegal. Standard header <code>&lt;ctype.h&gt;</code> defines family of functions that make it easier to convert independent of character set. Float to int causes truncation of any fractional part. Type conversions can be forced with &#39;cast&#39; <code>sqrt((double) n)</code> convert n from int to double before taking sqrt. </p>
<h3 id="2-8-increment-and-decrement-operators">2.8 Increment and Decrement Operators</h3>
<p>Increment and decrement operators can be used as prefix and suffix <code>i++ ++i i-- --i</code>. i++ increments the value after it is used, while ++i increments the value before it is used. </p>
<h3 id="2-9-bitwise-operators">2.9 Bitwise Operators</h3>
<p>Bitwise operators can only be applied to integral operands char, short, int and long. They are:</p>
<ul>
<li>&amp; - bitwise AND;</li>
<li>| bitwise OR; </li>
<li>^ bitwise XOR; </li>
<li>&lt;&lt; left shift; </li>
<li>>&gt; right shift; </li>
<li>~ one&#39;s complement </li>
</ul>
<p>Shift operators shift a bit by specified number of positions <code>x &lt;&lt; 2</code> shift x value two positions to the left, which is equivalent to multiplying by 4. </p>
<h3 id="2-10-assignment-operators-and-expressions">2.10 Assignment Operators and Expressions</h3>
<p>Assignment operators can be used to compress assigning a new value to a variable <code>i = i + 2</code> is equal to <code>i += 2</code>. All binary operators can be used as assignment operators (*=, -=, %=, &lt;&lt;= etc.).</p>
<h3 id="2-11-conditional-expressions">2.11 Conditional Expressions</h3>
<p>Conditional expressions are used to shorten if else statements <code>expr1 ? expr2 : expr3</code> if expr1 is true, then expr2 is evaluated, else expr3 is evaluated. For example <code>z = (a &gt; b) ? a : b;</code> sets z to the maximum of (a,b). </p>
<h3 id="2-12-precedence-and-order-of-evaluation">2.12 Precedence and Order of Evaluation</h3>
<p>--- Precedence Table ---</p>
<ol>
<li>() [] -&gt; .</li>
<li>! ~ ++ -- + - * (type) sizeof</li>
<li>* / %</li>
<li>+ -</li>
<li>>&gt; &lt;&lt;</li>
<li>&lt; &lt;= &gt; &gt;=</li>
<li>== !=</li>
<li>&amp;</li>
<li>^</li>
<li>|</li>
<li>&amp;&amp;</li>
<li>||</li>
<li>?:</li>
<li>= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;=</li>
<li>,</li>
</ol>
<p>Writing code that depends on order of evaluation is bad programming practice in any language. </p>
<h2 id="3-control-flow">3 - CONTROL FLOW</h2>
<h3 id="3-1-statements-and-blocks">3.1 Statements and Blocks</h3>
<p>Semicolon is a statement terminator <code>x = 0;</code>. Braces { and } group declarations and statements together. </p>
<h3 id="3-2-if-else">3.2 If-Else</h3>
<p>If-else is used to express decisions. To check if a expression is not equal to 0, we can use shortcut <code>if (expression)</code> in place of <code>(expression != 0)</code>. Else if associated with the closest if. The compiler doesn&#39;t take into account indentation, so use braces around nested if statements.</p>
<h3 id="3-3-else-if">3.3 Else-If</h3>
<p>Else-If is written as <code>else if</code> in C. If one of the else if statements evaluates to true, all other remaining expression are skipped. The else statement can be omitted. </p>
<h3 id="3-4-switch">3.4 Switch</h3>
<p>Switch statement is a way to test if an expresion matches one of a number of branches</p>
<pre><code><span class="hljs-keyword">switch</span>(expression) { 
<span class="hljs-keyword">case</span> <span class="hljs-keyword">const</span>-expr: statements  
<span class="hljs-keyword">default</span> : statements 
}
</code></pre><p>A break statement causes an immediate exit from the switch <code>break;</code>. Unless break is invoked, all switch cases are checked, even if one case already evaluated to true. Best practices is to add a break; after the default statement, even if it is not necessary.</p>
<h3 id="3-5-loops-while-and-for">3.5 Loops - While and For</h3>
<p>A <code>while</code> expression continues evaluation until it&#39;s condition is not met </p>
<pre><code><span class="hljs-keyword">while</span> <span class="hljs-comment">(expression)</span>
stateme<span class="hljs-symbol">nt</span>
</code></pre><p>A <code>for</code> statement provides a starting condition, a testing condition, and a incrementing condition. Any of these conditions can be omitted, but the semicolons have to be inserted. Multiple expressions can be inserted inside a for expression by separating them with a comma.</p>
<pre><code>for (initial_expr<span class="hljs-comment">; test_expr; increment_expr)</span>
statement
</code></pre><p>While and for loops can be used interchangeably. For loops are preferred for situations where there is a simple initialization and incrementing step.</p>
<h3 id="3-6-loops-do-while">3.6 Loops - Do-While</h3>
<p>In contrast to for and while loopse the <code>do-while</code> loop first executes the body and then tests a expression</p>
<pre><code><span class="hljs-keyword">do</span>
<span class="hljs-keyword">statement</span>
<span class="hljs-keyword">while</span> (expression);
</code></pre><p>In practice the do-while loop is much less used than for and while loopse. </p>
<h3 id="3-7-break-and-continue">3.7 Break and Continue</h3>
<p>A break statement can be used to exit a for, while or do loop early <code>break;</code>. Break causes the innermost loop to be exited immediately. A continue statement is similar to break, it causes the next iteration of an enclosing loop to be executed <code>continue;</code>. Continue does not work on switch statements, and is used more rarely. It can be used to simplify complicated loops so that the program doesn&#39;t nest too deeply.</p>
<h3 id="3-8-goto-and-labels">3.8 Goto and labels</h3>
<p>A <code>goto</code> statement is never necessary and can be easily abused. It may have a use in moving out from a deeply nested structure, since a break statement only breaks out of the innermost loop. Goto statements make maintaining code more challenging and generally harder to understand.</p>
<pre><code><span class="hljs-keyword">for</span> (...)
<span class="hljs-keyword">for</span> (...) {
<span class="hljs-keyword">if</span> ()
<span class="hljs-keyword">goto</span> <span class="hljs-built_in">error</span>;
}
<span class="hljs-built_in">error</span>:
</code></pre><h2 id="4-functions-and-program-structure">4 - FUNCTIONS AND PROGRAM STRUCTURE</h2>
<p>Functions hide details of computations to break larger programs into smaller ones. </p>
<h3 id="4-1-basics-of-functions">4.1 Basics of Functions</h3>
<p>Function definition has form:</p>
<pre><code><span class="hljs-keyword">return</span>-<span class="hljs-built_in">type</span> <span class="hljs-function"><span class="hljs-keyword">function</span>-<span class="hljs-title">name</span> <span class="hljs-params">(arguments)</span></span>
{
declarations <span class="hljs-keyword">and</span> statements
}
</code></pre><p>If return type is omitted, int is assumed. The return expression <code>return expression;</code> converts the expression to the return type if necessary. If a functions fails to return a value, the value will likely be useless. Compiling and load a C program stores in 3 different files can be done on UNIX with command.</p>
<pre><code>$ cc main<span class="hljs-selector-class">.c</span> filename1<span class="hljs-selector-class">.c</span> filename2.c
</code></pre><h3 id="4-2-functions-returning-non-integers">4.2 Functions Returning Non-integers</h3>
<p>To return a value of type other than int, we must declare the function to return that type. Additionally the calling routine must know that the function returns a non-int value. To explicitly state the return value: <code>double var_name, function_name(arguments);</code>.</p>
<h3 id="4-3-external-variables">4.3 External Variables</h3>
<p>External variables are defined outside of a function. Functions are always external, C doesn&#39;t allow nesting of functions. External variables should be used when the variables are shared among many functions, and if a longer lifetime for the variables are needed. </p>
<h3 id="4-4-scope-rules">4.4 Scope Rules</h3>
<p>The <em>scope</em> of a name is the part of the program within which a name can be used. Variables declared at the beginning of a function, and function parameters are local to their function. An external variable lasts from declaration until the the end of the file is compiled. To use an external variable from a different file or before it is declared the <code>extern</code> declaration has to be used. Declarations simply declare the type of a variable name or function for the rest of the file <code>extern double val[]</code>. Definitions declare the type and additionally create variable and set aside storage <code>double val[SIZE];</code>. There can only be one definition of an external variable among all the source files, but there can be more than one declaration of the variable. </p>
<h3 id="4-5-header-files">4.5 Header Files</h3>
<p>Common definitions and declarations are placed in a <em>header</em> (file name extension .h). To include a header in a .c file we write <code>#include &quot;header_name.h&quot;</code>. For a moderate program size, one header is usually enough, for a much larger program more headers and organization are needed.</p>
<h3 id="4-6-static-variables">4.6 Static Variables</h3>
<p>A <code>static</code> declaration of an external variable or function limits the scope of that object to the rest of the source file. Once declared as static no other routine will be able to access the static object. Static variables declared inside a function remain in existence rather than changing with each function call. </p>
<h3 id="4-7-register-variables">4.7 Register Variables</h3>
<p>A <code>register</code> declaration tells the compiler that the variable declared will be heavily used. This may result in faster and smaller programs. A variable is declared as register with <code>register int x;</code>. There are restrictions on the number and types of register variables depending on the machine.</p>
<h3 id="4-8-block-structure">4.8 Block Structure</h3>
<p>Declarations of variables can follow the left brace of any compound statement, not just functions. For example:</p>
<pre><code><span class="hljs-keyword">if</span> ( ) {
<span class="hljs-keyword">int</span> x;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">while</span> x ...)
}
</code></pre><p>In the above example x is local to the if statement, and is unrelated to any other variable named x outside it&#39;s scope. Best practice is to avoid reusing names for local variables.</p>
<h3 id="4-9-initialization">4.9 Initialization</h3>
<p>When not explicitly initialized, external and static variables are initialized to 0. Automatic and register variables have undefined initial values. Variables can be defined and initialized at the same time; for example <code>int x = 1</code>. For external and static variables initialization is done once. For automatic and register variables, the value doesn&#39;t have to be a constant. It can be any other previously defined value and function. </p>
<p>Array can be initialized with a list enclosed in braces, separated by commas: <code>int days[] = { 31, 28, 31, 5, 10, 1, 2 };</code>. If the size of the array is not explicitly stated, the compiler will count the number of variables in the initialization (7 in the above example). If there are fewer initialized variables than the size of the array, then the rest will be set to 0. There is no way to set a value in the middle of an array without initializing the preceding values. For char arrays, there is a shortcut for initialization by using a string <code>char pattern = &quot;ould&quot;;</code>. </p>
<h3 id="4-10-recursion">4.10 Recursion</h3>
<p>C functions can be used recursively. Each recursive call resets all the automatic variables. Recursion doesn&#39;t save storage, nor is is faster. It is however more compact and often easier to understand. </p>
<h3 id="4-11-the-c-preprocessor">4.11 The C Preprocessor</h3>
<p>Most common features of preprocessor are: <code>#include</code>, which includes contents of a file; <code>#define</code> which replaces a token by a sequence of characters.</p>
<h4 id="4-11-1-file-inclusion">4.11.1 File Inclusion</h4>
<p>A file can be included by writing either <code>#include &quot;filename&quot;</code> or <code>#include &lt;filename&gt;</code>. Searching for the filename usually begins in the directory where the source program was found. </p>
<h4 id="4-11-2-macro-substitution">4.11.2 Macro Substitution</h4>
<p>Definition has the form <code>#define name replacement text</code>. Scope of a defined name is until the end of the source file. A definition name doesn&#39;t have to be a constant in the strictest sense, for example <code>#define forever for (;;)</code> or <code>#define max(A, B) ((A) &gt; (B) ? (A) : (B))</code>. The second example is also called a <em>macro</em>, where the replacement text changes based on the input values, similar to a function. </p>
<h4 id="4-11-3-conditional-inclusion">4.11.3 Conditional Inclusion</h4>
<p>Preprocessing itself can also be controlled with conditional statements. If a <code>#if</code> statement is non-zero, then subsequent lines until an <code>#endif</code> or <code>elif</code> are included. This is useful to avoid including files multiple times:</p>
<pre><code><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(HDR)    <span class="hljs-comment">/* Can also be written #ifndef HDR */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HDR</span>
<span class="hljs-comment">/* hdr.h content */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>


<div class="citations">
<strong>References:</strong>
<ol>
<li id="cite1">Kernighan, B. W., & Ritchie, D. M. (2006). The C programming language.</li>
</ol>
</div>

</main>

<footer>
<a href="#">^ back to top</a><br><br>
<a href="/about">about</a>
</footer>

</body>
