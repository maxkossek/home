---
layout: post
title: C
date: 2019-10-26
categories: [man]
tags: [programming language]
author: "Max Kossek"
description: Reference for C programming language syntax.
sitemap:
    lastmod: 2020-05-11
---

NAME
----

C - General-purpose, procedural programming language.


DESCRIPTION
-----------

Every C program starts its execution at the `main()` function. The "#include" keyword includes the function declarations of a header file. Standard library function names are enclosed in <> while user-defined headers are enclosed in double quotes "".
```
#include <stdio.h>
#include "test.h"

int
main(int argc, char *argv[])
{
	return 0;
}
```

Header files with the file extension ".h" are used to define a public interface for ".c" files. Headers should include a header guard using "#ifndef" to prevent duplicate declarations.
```
#ifndef TEST_H
#define TEST_H

int example_func(int, char*);
...

#endif
```

The gcc and clang compilers can be used to compile C files.
```
$ clang -o prog main.c
$ ./prog
```


INPUT / OUTPUT
--------------

The `argc` and `*argv[]` arguments store the number of arguments and the argument vector passed to the `main()` function.
```
if (argc == 2)
	str = argv[1];
```

Include the library `<stdio.h>` for standard input and output functions. The `printf()` function is used to print to STDOUT. The percent character ("%") signals a formatting directive.
```
printf("Float: %3.2f", x);
```

Data type directives for `printf()`:

%c - Char data type.

%s - String data type.

%d / %i - Integer data type.

%u - Unsigned integer data type.

%f - Floating point number data type.

%3.2f - Width and number of digits after the decimal point.

%x - Hexadecimal representation.

%-10s - Right-justify text.


The `scanf()` and `getchar()` functions can be used to read input from STDIN.
```
scanf("%d", num);
scanf("%s", str);
char c = getchar();
```

The `fopen()` function is used for file input and output. Modes: "r" = read, "w" = write, "a" = append. Use `fgets()` or `getc()` to read contents from a file. `putc()` writes a single character to a file.
```
FILE *fopen(char *name, char *mode);

FILE *fr;
fr = fopen("input.txt", "r");
getc(fr);
fgets(&line, LEN, fr);
ssize_t s = getline(&line, &len, fr);
fclose(fr);

FILE *fw;
fw = fopen("output.txt", "w");
putc(int c, FILE *fw);
fprintf(fw, "Writing to file: %d", x);
fclose(fw);
```


OPERATORS
---------

Arithmetic operators: +, -, *, /, %.
```
x = 2 + 5 * 1;
```

Bitwise Operators: & (AND), | (OR), ^ (XOR), << (left shift), >> (right shift), ~ (one's complement).
```
x = ~y;
z = x & y;
x = y << 2;
```

Relational operators: <, >=, ==, !=.
```
i <= 10;
```

Logical Operators: && (AND), || (OR), ! (NOT).
```
i < 10 && c != '\n'
```

Increment and decrement operators: ++, --. i++ reads the variable first and then increments it. ++i increments the value of the variable and then reads it's value.
```
i++;
```

Assignment operators: +=, -=, *=, /=, %=.
```
i += 10;
```


STRINGS
-------

The '\0' character marks the termination of a string. When outputting a string the loop should check for the terminating '\0' character.
```
char str[10];
char *str = "abc";

for (char *i = str; *i != '\0'; i++) {
	printf("%c", *i);
}
```

The `<string.h>` header file provides a number of useful string functions. The `strchr()` locates the first occurrence of a chararcter in the string, and returns the location. The `strrchr()` is the same as `strchr()`, except that it locates the last occurrence of the character.
```
strchr(buf, '.');
```

The `strlcpy()` and `strlcat()` functions defined in `<string.h>` are designed to be safer alternatives for copying and concatenating strings. Both functions check the size of the buffer to prevent buffer overflows and append the string termination character '\0'.
```
strlcpy(buf, "set to this", sizeof(buf));
strlcat(buf, "add this", sizeof(buf));
```


VARIABLES
---------

Local variables must be declared with a data type. Global variables are declared with the "extern" keyword. The "const" keyword makes a variable immutable.
```
int x, y;
float x = 3.534;
char *str = "Hello World";

extern int x = 1;
const double e 2.7182;
```


The #define" keyword can be used for macros. A macro replaces all occurrences of a string with the specified value at compile time. Macros spanning multiple lines must use the backslash ("\") as a continuation character.
```
#define SIZE 100
#define SWAP(t, x, y)	t z = y; y = x; x = z
#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

#define ADD_ACC(x, y) do {	\
	x = (x) + (y);		\
	(y) += 1;		\
} while (0)
```


POINTERS
--------

Pointers are variables that point to a memory address. The "&" operator is used to access a variables address. The "*" operator is used to dereference the contents of a pointer. Pointers can point to other pointers.
```
int *p;
*p = &x;
*p = 0;
y = *p + 5;
int ++p;
```

A pointer can be assigned to an element in the array. Pointer arithmetic such as *++p walks a pointer along an array. It's important to check for bounds or string termination characters.
```
*(z+i);
*p++;
```


ARRAYS
------

Arrays can be declared as empty or with explicitly initialized values.
```
int num[10];
int num[] = { 1, 2, 3 };
num[2] = 4;
```


FUNCTIONS
---------

Function prototypes have to be declared before the `main()` function or in a ".h" file. Specifying the parameters names is optional, but recommended. Declaring a function with the "static" keyword restricts its visibility to the current file.
```
int func_name(int x, int y);
```

Every function has to specify it's return type, name, and parameters. Parameter names are not optional when defining a function. Variables declared inside a function are local to that function. By default, C passes arguments by value.
```
int
func_name(int x, int y)
{
	return x + y;
}
```


STRUCTS
-------

Structs are a collection of variables in a single structure. Struct members have to be accessed using the "->" operator if the variable is a pointer to a struct.
```
struct point {
	int x;
	int y;
};

struct point coor;
coor.x = 100;
printf("%d", coor.x);

struct point *coor;
coor->x = 50;
printf("%d", coor->x);
```


ENUMS
-----

Enumerations map integers to names in the program. By default, the first element in the enum gets the value 0, the second the value 1, and so on. Most conventions use uppercase names for enumeration identifiers.
```
enum boolean {NO, YES};
enum months {JAN = 1, FEB, DEC = 12};

enum months current = FEB;
printf("%u", current);
```


CONDITIONALS
------------

If-else statements can have multiple optional else if blocks.
```
if (x < 0) {
	y = -1;
	return;
}
else if (x > 0)
	y = 1;
else
	y = 0;
```

Switch statements check for different values for a char or int variable. The switch statement will continue evaluating all options unless there is a break statement.
```
switch (i) {
case 0:
	i = 50;
case i > 0:
	i += i;
	break;
default:
	break;
}
```


LOOPS
-----

While loops are evaluated until the condition no longer holds. Do-while loops act the same as while loops except that they begin by executing a statement and only then test for a condition.
```
while (i < 0)
	i++;

do {
	i++;
} while (i < 0);
```

For loops have optional initialization, condition and incrementing statements. Multiple statements can be separated by a comma.
```
for (int i = 2, y = 0; i < 10; y++)
	i += y;
```

The "continue" keyword causes a loop to skip to the next iteration. The "break" keyword terminates the innermost loop.



ERRORS
------

Error messages can be written to STDERR using `fprintf()`. The `strerror()` function in `<errno.h>` prints a textual description for an error code. The `perror()` prints the error message associated with the current value of the global `errno` variable.
```
fprintf(stderr, "Can't open %s\n", *argv);
fprintf(stderr, "EFAULT: %s\n", strerror(EFAULT));
perror(NULL);
```

The `err()` function in `<err.h>` displays a formatted error message to the standard output.
```
err(1, "hostname");
```



MEMORY
------

Memory can be dynamically allocated on the heap using `malloc()`. All malloc'd memory has to be explicitly freed by the user by calling `free()`.
```
int *ip = malloc(sizeof(int));
struct Node *temp = malloc(sizeof(struct Node));
free(temp);
```
