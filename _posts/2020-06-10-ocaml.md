---
layout: post
title: OCaml
date: 2020-06-10
categories: [man]
tags: [language, functional]
author: "Max Kossek"
description: Reference for the OCaml functional programming language.
sitemap:
    lastmod: 2020-06-13
---

NAME
----

OCaml -- Strongly-typed, functional language of the ML family.



DESCRIPTION
-----------

OCaml source code files have a ".ml" extension. Interface files contain function signatures and have a ".mli" extension. The "-i" command line option prints all the names and type signatures in a ".ml" source file.
```
$ ocamlc -i file.ml
```

The Hello World program in OCaml. Use `ocamlc` to compile the program. The `ocamlbuild` command automatically finds and links libraries. It creates a new directory "_build" which stores the modules and linked files. Use the "-clean" option to remove the "_build" directory.
```
$ cat > hello.ml
let _ = print_endline "Hello world"
$ ocaml hello.ml
Hello world
$ ocamlc -o hello hello.ml
$ ./hello
Hello world
$ rm hello
$ ocamlbuild hello.byte
Finished, 3 targets (0 cached) in 00:00:00.
% _build/hello.byte
Hello world
$ ocamlbuild -clean
```

The `$ ocaml` command starts the toplevel OCaml interpreter. Press "Ctrl-D" or type `#quit ;;` to exit the toplevel interpreter. The `utop` interpreter is a more feature rich alternative to the standard interpreter.
```
$ ocaml
# #quit ;;
```

Expressions in the toplevel must be separated using the double semicolon (";;"). The double semicolon is unneccessary in source code files.
```
# let x = 5 ;;
val x : int = 5
```

The single semicolon chains together a number of expressions that have the return value `()`. This operator is used for instructions that have side-effects. To write a sequence of side-effect expressions and disregard their unit return value in a source file, use the syntax: `let () = e1; ... en`.
```
# print_string "Hello";
  print_string "World";
  print_char '!' ;;
HelloWorld!- : unit = ()
```

The `#use` directive loads a OCaml source file into the REPL. The `#load` directive loads a library into the REPL.
```
# #use "file.ml" ;;
# #load "str.cma" ;;
```

Comments being with `(*` and end with `*)`. The OCamldoc tool automatically extracts comments for documentation. OCamldoc comments must begin with a double asterisk `(**`. Content inside square brackets is rendered in typewriter font. OCamldoc also supports the following documentation tags: `@author`, `@deprecated`, `@param`, and `@return`.
```
(** @author First Last_Name *)

(** [compare x y] compares the strings [x] and [y] lexicographically *)
(** @return 1 if [x] > [y], -1 if [y] < than [x], else 0. *)
val compare : string -> string -> int

(** [sum lst] is the sum of the elements of list [lst].
    The sum of an empty list is 0. *)
let rec sum lst = ...

(** [index s c] is the index of the first occurrence of
    character [c] in string [s].  Raises: [Not_found]
    if [c] does not occur in [s]. *)

$ ocamldoc -man file.ml
$ man ./File.3o
```

The `opam` command invokes OCaml's standard package manager. The `ocamlformat` tool is an automated code formatting tool.
```
$ opam install ocamlformat
```



INPUT / OUTPUT
--------------

The `print_string` and `print_endline` functions print an unformatted string to the standard output. The `print_endline` function appends a newline character ("\n") to the end of the output. There are built-in print functions for most of the primitive types: `print_bytes`, `print_char`, `print_float`, `print_int`.
```
# print_string "hello world" ;;
hello world- : unit = ()
# print_endline "hello world" ;;
hello world
- : unit = ()
```

`Printf.printf` prints a formatted string to the standard output.
```
# Printf.printf "String: %s; Int: %d" "hello" 5 ;;
String: hello; Int: 5- : unit = ()
```

The `read_line` function reads a line of input from the standard input.
```
# let x = read_line () ;;
5
val x : string = "5"
```



DATA TYPES
----------

`'a`, `'b`, `'c`, ...
: Unknown types.

`bool`
: Boolean value, either `false` or `true`.

`bytes`
: Byte sequence.

`char`
: Character value enclosed in single quotes ("'").

`exn`
: Exception value.

`int`, `int32`, `int64`, `nativeint`
: Integer values: `1`, `5`, `30_000_000`, `50_0_00`, `min_int`, `max_int`.

`float`
: Floating point value: `1.`, `3.14`, `1e5`, `1e-9`, `min_float`, `max_float`, `epsilon_float`, `neg_infinity`, `infinity`, `nan`.

`t ref`
: Reference type, pointer to a mutable value of type `t`.

`string`
: Read-only string enclosed in double quotes ("""). Strings are not arrays of `char`s.

`unit`
: Unit value: `()`.

`'a array`
: Array with elements of type `'a`.

`'a list`
: List with elements of type `'a`: `type 'a list = [] | :: of 'a * 'a list`.

`'a option`
: Optional value of type `'a`. Either `Some e` or `None`.

```
# 5 ;;
- : int = 5
# 3. ;;
- : float = 3.
# "hello" ;;
- : string = "hello"
# 'a' ;;
- : char = 'a'
# () ;;
- : unit = ()
# [1; 2; 3] ;;
- : int list = [1; 2; 3]
# Some 5 ;;
- : int option = Some 5
# None ;;
- : 'a option = None
```

The "type" keyword allows you to define your own data type.
```
# type year = int ;;
type year = int
# let birthyear : year = 1900 ;;
val birthyear : year = 1900
# birthyear + 5 ;;
- : int = 1905

# type lisp_bool = T | NIL ;;
type lisp_bool = T | NIL
# let lb = NIL ;;
val lb : lisp_bool = NIL

# type point2d = Point of float * float ;;
type point2d = Point of float * float
# let p = Point (3.0, 5.0) ;;
val p : point2d = Point (3., 5.)

# type point = { x : int64; y : int64 } ;;
type point = { x : int64; y : int64; }
```

A type synonym is an alias for an existing type. Type synonyms are interchangeable with their underlying type.
```
# type num = int ;;
type num = int
# let x : num = 5 ;;
val x : num = 5
# x + 3 ;;
- : int = 8
```

The `ignore` function ignores a value's type and converts to the unit type `()`.
```
# ignore 5 ;;
- : unit = ()
# ignore 3 ; 5 ;;
- : int = 5
```



OPERATORS
---------

Operators can be written as prefix or infix. Note: When writing the multiplication operator as prefix, use `( * )` not `(*)` to avoid it being parsed as a comment.
```
# 1 + 2 ;;
- : int = 3
# ( + ) 1 2 ;;
- : int = 3

# ( * ) 1 2 ;;
- : int = 2
# (*) 1 2 ;;
Warning 1: this `(*' is the start of a comment.
Hint: Did you forget spaces when writing the infix operator `( * )'?
```

Integer arithemtic operators: `+`, `-`, `*`, `/`, `mod`.
```
# 3 + 2 * 4 ;;
- : int = 11
# 17 mod 9 ;;
- : int = 8
```

Floating point arithemtic operators: `+.`, `-.`, `*.`, `/.`, `**` (exponentiation).
```
# 3.0 +. 2.5 *. 2.0 ;;
- : float = 8.
# 3. -. 2. ;;
- : float = 1.
```

Unary operators: `~+` (integer positive), `-` (polymorphic negative), `~-` (integer negative), `~-.` (float point negative).
```
# - 5 ;;
- : int = -5
# - 5. ;;
- : float = -5.
# ~- 3 ;;
- : int = -3
# ~-. 3. ;;
- : float = -3.
```

Increment / decrement operators: `succ`, `pred`.

Bitwise operators: `land`, `lor`, `lxor`, `lnot`, `lsl` (logical shift left), `lsr` (logical shift right), `asr` (arithemtic shift right).

Boolean operators: `not`, `&&`, `&`, `||`, `or`.
```
# true || false && true ;;
- : bool = true
# not true ;;
- : bool = false
```

Relational operators: `=` (structural equality), `<>` (structural inequality), `==` (physical equality), `!=` (physical inequality), `<`, `<=`, `>`, `>=`. Physical equality checks should primarily be used for `ref` variables, since they compare the memory addresses of two values.
```
# "abc" = "abc" ;;
- : bool = true
# "abc" == "abc" ;;
- : bool = false
# assert (3 <> 5) ;;
- : unit = ()

# let x = ref 5 ;;
val x : int ref = {contents = 5}
# let y = ref 5 ;;
val y : int ref = {contents = 5}
# x = y ;;
- : bool = true
# x == y ;;
- : bool = false
# let y = x ;;
val y : int ref = {contents = 5}
# x = y ;;
- : bool = true
# x == y ;;
- : bool = true
```

Concatenation operators: `@` (list concatenation, takes constant time), `^` (string concatenation).
```
# [1; 2] @ [3; 4] ;;
- : int list = [1; 2; 3; 4]
# "hello" ^ " world" ;;
- : string = "hello world"
```

Pointer operators: `!` (dereferencing).



VARIABLES
---------

Variable names should be lower case and use underscores (`var_name`), not camelcase. The apostrophe character ("'") is also allowed.

The "let" keyword binds a value to a name. A variable definition generally has the syntax: `let v = e`.
```
# let x = 5 ;;
val x : int = 5
# let x = "hello" ;;
val x : string = "hello"
```

The "let" keyword can also be used to bind a value to a local scope, using the syntax: `let v = e1 in e2`. If an identifier is defined multiple times in the same scope, then the later definitions shadow the ealier ones.
```
# let x = 5 in
let y = 10 in
x + y
;;
- : int = 15

# let x = 0 in
let x = 1 in
x
;;
Line 1, characters 4-5:
Warning 26: unused variable x.
- : int = 1

# let x = 0 in
let y = x in
let x = 1 in
y
;;
Line 3, characters 4-5:
Warning 26: unused variable x.
- : int = 0
```



FUNCTIONS
---------

Functions are first-class citizens that can be treated as ordinary values. They can be used as arguments to other functions, as return values, and assigned to other values.

The "let" keyword binds a function to its definition. A function definition definition has the form: `let f a1 ... an = e`. A function application has the syntax: `e0 e1 e2 ... en`. Function parameters can be passed with or without parenthesis ("()"). The infix operator `|>` allows you to write a function application from left to right. Function applications are left associative, while function types are right associative.
```
# let inc x = x + 1 ;;
val inc : int -> int = <fun>
# inc(1) ;;
- : int = 2
# inc 5 ;;
- : int = 6
# 3 |> inc |> inc ;;
- : int = 5
```

It is common for `let` expressions to be nested inside other `let` expressions. For example, the following function defines a helper function for calculating the nth Fibonnaci number using tail recursion.
```
# let fib n =
  let rec fib_h m a b =
    match m with
    | 0 -> a
    | _ -> fib_h (m - 1) b (a + b)
  in
  fib_h n 0 1
  ;;
val fib : int -> int = <fun>
```

Functions with no arguments must be written with the empty argument list "()".
```
# let greeting () = print_endline "hello world" ;;
val greeting : unit -> unit = <fun>
# greeting () ;;
hello world
- : unit = ()
```

Functions can be written with labeled arguments using the syntax: `~name:arg`. The `arg` part of the syntax is optional. To give an explicit type annotation to a labeled argument use the syntax: `~name:(arg:type)`.
```
# let div ~x:num ~y:den = num /. den ;;
val div : x:float -> y:float -> float = <fun>
# div ~y:2.5 ~x:5. ;;
- : float = 2.
# div 2.5 5. ;;
- : float = 0.5

(** Simplified labeled argument syntax. *)
# let conc ~l1 ~l2 = l1 @ l2 ;;
val conc : l1:'a list -> l2:'a list -> 'a list = <fun>
# conc ~l2:[3; 4] ~l1:[1; 2] ;.;
- : int list = [1; 2; 3; 4]

(** Explicit Type Annotation *)
# let int64_inc ~i:(i:int64) = Int64.add i 1L ;;
val int64_inc : i:int64 -> int64 = <fun>
# int64_inc 5L ;;
- : int64 = 6L
```

The OCaml compiler can perform type inference on most operations. To explicitly write the type annotation of a function use the syntax: `let f (a1 : t1) ... (an : t2) : rt = ...`. Alternatively, the type signature can be placed in a ".mli" interface file using the syntax: `val f : t1 -> ... -> tn -> rt`.
```
# let add (x : int) (y : int) : int = x + y ;;
val add : int -> int -> int = <fun>
# add 5 3 ;;
- : int = 8
```

Optional arguments are written with the syntax: `?name:(arg=default_value)`.
```
# let add ?x:(x=0) y = x + y ;;
val add : ?x:int -> int -> int = <fun>
# add 5 ;;
- : int = 5
# add ~x:10 5 ;;
- : int = 15
```

The "let...in" construct chains together multiple expressions so that several variables can be bound to the same code block. A variable is scoped to its nearest enclosing `let` expression.
```
# let x = 1 in x + 1 ;;
- : int = 2
# let x = 1 in
  let y = 2 in
  x + y ;;
- : int = 3
```

Recursive functions must be defined with the "rec" keyword.
```
# let rec factorial n =
    if n = 0 then 1
    else n * factorial (n-1)
;;
val factorial : int -> int = <fun>
# factorial 5 ;;
- : int = 120
```

Mutually recursive functions are defined with the "and" keyword.
```
# let rec even n =
  n = 0 || odd (n - 1)
  and odd n =
  n <> 0 && even (n - 1)
;;
val even : int -> bool = <fun>
val odd : int -> bool = <fun>
# even 5 ;;
- : bool = false
```

Anonymous / lambda functions have the following syntax: `fun x1 ... xn -> e`. A `let` expression of the form `let x = e1 in e2` is equivalent to the anonymous function `(fun x -> e2) e1`.
```
# (fun x -> x + 1) 3 ;;
- : int = 4
# let l = fun x -> x * x ;;
val l : int -> int = <fun>
# l 5 ;;
- : int = 25
# List.map (fun x -> x + 5) [ 1; 2; 3 ] ;;
- : int list = [6; 7; 8]

(** The following three are equivalent. *)
# let add x y = x + y ;;
val add : int -> int -> int = <fun>
# let add x = fun y -> x + y ;;
val add : int -> int -> int = <fun>
# let add = fun x -> fun y -> x + y ;;
val add : int -> int -> int = <fun>
```



LISTS
-----

Lists are immutable and must only consist of elements of a single type. Lists are enclosed in square brackets ("[]"), with the elements separated by semicolons (";"). The empty list is reprented as: `[]`.
```
# let my_list = [1; 2; 3] ;;
val my_list : int list = [1; 2; 3]
# [] ;;
- : 'a list = []
```

The cons operator is represented by a double colon ("::"). It construct a new list by adding an element to the beginning of the list.
```
# 1 :: [2; 3] ;;
- : int list = [1; 2; 3]
```

Lists can be nested.
```
# [[1; 2]; [3; 4]; []] ;;
- : int list list = [[1; 2]; [3; 4]; []]
```



LIST
----

The `List` modules has functions for performing list operations.


### LIST ACCESS

List access functions: `List.find`, `List.hd`, `List.nth`, `List.nth_opt`, `List.tl`.

`List.find` returns the first element of the list that satisfies a predicate.
```
# List.find ;;
- : ('a -> bool) -> 'a list -> 'a = <fun>
# List.find (fun x -> x mod 2 = 0) [1; 2; 3] ;;
- : int = 2
```

`List.hd` returns the first element of the list. Applying this function to an empty list raises an exception.
```
# List.hd ;;
- : 'a list -> 'a = <fun>
# List.hd [1; 2; 3] ;;
- : int = 1
# List.hd [] ;;
Exception: Failure "hd".
```

`List.nth` returns the nth element of the list.
```
# List.nth ;;
- : 'a list -> int -> 'a = <fun>
# List.nth [1; 2; 3] 0 ;;
- : int = 1
# List.nth [1; 2; 3] 3 ;;
Exception: Failure "nth".
```

`List.nth_opt` returns the nth element of the list, and `None` if the list is too short.
```
# List.nth_opt ;;
- : 'a list -> int -> 'a option = <fun>
# List.nth_opt [] 3 ;;
- : 'a option = None
# List.nth_opt [1; 2; 3] 3 ;;
- : int option = None
# List.nth_opt [1; 2; 3] 0 ;;
- : int option = Some 1
```

`List.tl` returns the list without its first element. Applying this function to an empty list raises an exception.
```
# List.tl ;;
- : 'a list -> 'a list = <fun>
# List.tl [1; 2; 3] ;;
- : int list = [2; 3]
# List.tl [] ;;
Exception: Failure "tl".
```


### LIST CONSTRUCTION

List construction functions: `List.append`, `List.concat`, `List.cons`, `List.flatten`, `List.rev_append`.

`List.append` concatenates two lists.
```
# List.append ;;
- : 'a list -> 'a list -> 'a list = <fun>
# List.append [1; 2] [3; 4] ;;
- : int list = [1; 2; 3; 4]
```

`List.concat` and `List.flatten` concatenate a list of lists.
```
# List.concat ;;
- : 'a list list -> 'a list = <fun>
# List.concat [[1; 2]; [3; 4]] ;;
- : int list = [1; 2; 3; 4]
```

`List.cons` conses an element to the front of a list.
```
# List.cons ;;
- : 'a -> 'a list -> 'a list = <fun>
# List.cons 1 [2; 3] ;;
- : int list = [1; 2; 3]
```

`List.rev_append` reverses the first list and then concatenates it to the second list.
```
# List.rev_append ;;
- : 'a list -> 'a list -> 'a list = <fun>
# List.rev_append [1; 2] [3; 4] ;;
- : int list = [2; 1; 3; 4]
```



### LIST MODIFICATION

List modification functions: `List.filter`, `List.fold_left`, `List.fold_right`, `List.map`, `List.rev`.

`List.filter` filters a list based on a predicate function.
```
# List.filter ;;
- : ('a -> bool) -> 'a list -> 'a list = <fun>
# List.filter (fun x -> x mod 2 = 0) [1; 2; 3; 4] ;;
- : int list = [2; 4]
```

`List.fold_left` and `List.fold_right` fold all elements of a list based on a combining function. The first argument is the combining function. The second argument is the accumulator for `List.fold_left`, and the combining function for `List.fold_right`. The third argument is the combining function for `List.fold_left`, and the initial value for `List.fold_right`.
```
# List.fold_left ;;
- : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a = <fun>
# List.fold_left (^) "start" [ "a"; "b"; "c" ] ;;
- : string = "startabc"

# List.fold_right ;;
- : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b = <fun>
# List.fold_right (+) [1; 2; 3] 0 ;;
- : int = 6
```

The `List.fold_left` and `List.fold_right` evaluate their arguments differently. `List.fold_left` combines the elements left to right, while `List.fold_right` combines the list elements right to left. For non-associative operators, the two functions can evaluate to different answers. It also means that the two functions have different performance characteristics. `List.fold_left` is tail recursive, while `List.fold_right` is not. Prefer using `List.fold_left` for long list operations to avoid stack overflows.
```
# List.fold_right (-) [ 1; 2; 3 ] 0 ;;
- : int = 2
# List.fold_left (-) 0 [ 1; 2; 3 ] ;;
- : int = -6
```

`List.map` applies a function to each elemnt in the list.
```
# List.map ;;
- : ('a -> 'b) -> 'a list -> 'b list = <fun>
# List.map (( + ) 5) [1; 2; 3] ;;
- : int list = [6; 7; 8]
# List.map String.length ["hello"; "world"; "!"] ;;
- : int list = [5; 5; 1]
```

`List.rev` reverses the list.
```
# List.rev ;;
- : 'a list -> 'a list = <fun>
# List.rev [1; 2; 3] ;;
- : int list = [3; 2; 1]
```


### LIST PROPERTIES

List property functions: `List.length`, `List.mem`.

`List.length` returns the length of a list.
```
# List.length ;;
- : 'a list -> int = <fun>
# List.length [1; 2; 3] ;;
- : int = 3
```

`List.mem` returns true if the element is a member of the list.
```
# List.mem ;;
- : 'a -> 'a list -> bool = <fun>
# List.mem 1 [1; 2; 3] ;;
- : bool = true
```



TUPLES
------

Tuples are a composite type that can contain elements of different types. A tuples elements are separated by a comma (",") and optionally enclosed in parenthesis ("()"). A tuple declaration has the syntax: `(e1, ..., en)`.
```
# let tup = 1, 2 ;;
val tup : int * int = (1, 2)
# let tup = (3, 4) ;;
val tup : int * int = (3, 4)
# let tup = (true, "hello", 'a') ;;
val tup : bool * string * char = (true, "hello", 'a')
```

The parenthesis are optional when pattern matching.
```
# match (1, 2, 3) with (x, y, z) -> x + y + z ;;
- : int = 6
# match (1, 2) with x, y -> x + y ;;
- : int = 3
```



RECORDS
-------

Records are a user-defined composite type. Records can contain values of different data types. A record type declaration has the form: `type r = { f1 : t1; ...; fn : tn }`. To create an instance of the record type use the syntax: `{ f1 = e1; ...; fn = en }`. The order with which the fields are specified does not matter. The dot operator (".") is used to access a field inside the record: `r.f`.
```
# type person = { name : string; age : int; employed : bool } ;;
type person = { name : string; age : int; employed : bool; }
# let bob = { name = "Bob"; age = 50; employed = true } ;;
val bob : person = {name = "Bob"; age = 50; employed = true}
# bob.age ;;
- : int = 50
```

All the fields in a record must be defined. However, the "with" keyword can be used to construct a new record from an existing one.
```
# let ann = { name = "Ann" } ;;
Error: Some record fields are undefined: age employed
# let ann = { bob with name = "Ann" } ;;
val ann : person = {name = "Ann"; age = 50; employed = true}
```

Records can be pattern matched with or without assigning a name to the matched field.
```
# match bob with { name = n; age = a; employed = e } -> e ;;
- : bool = true
# match bob with { name; age; employed } -> employed ;;
- : bool = true
```

The fields of a record can be made mutable by using the "mutable" keyword. The records of the field can thenbe updated using the arrow operator ("<-") and the syntax: `r.f <- e`.
```
# type experiment = { mutable total: float; mutable samples: int } ;;
type experiment = { mutable total : float; mutable samples : int; }
# let e = { total = 0.0; samples = 0 } ;;
val e : experiment = {total = 0.; samples = 0}
# e.total <- e.total +. 1.5; e.samples <- e.samples + 1 ;;
- : unit = ()
# e ;;
- : experiment = {total = 1.5; samples = 1}
```



REFS
----

The `ref` type stores a single mutable value, like a pointer in an imperative language. Refs are implemented as a mutable record, with one field called `contents`. Using `ref` types introduces side effects to the program.
```
# let p = { contents = 0 } ;;
val p : int ref = {contents = 0}
# p.contents <- p.contents + 1 ;;
- : unit = ()
# p ;;
- : int ref = {contents = 1}
```

The `ref` type also has a number of syntactic shortcuts. For example, to create a `ref` you can write: `let r = ref e`. For assignment use the assignment operator ":=", so: `r := e`. To dereference the contents of the `ref` use the syntax: `!r`. The `incr` function increments the value of the reference.
```
# let q = ref 5 ;;
val q : int ref = {contents = 5}
# !q ;;
- : int = 5
# q := !q + 1 ;;
- : unit = ()
# !q ;;
- : int = 6
# incr q ;;
- : unit = ()
# !q ;;
- : int = 7
```

Assigning one a variable to another reference creates an alias. Any changes that one of the references makes will be visible to the alias reference.
```
# let x = ref 5 ;;
val x : int ref = {contents = 5}
# let y = x ;;
val y : int ref = {contents = 5}
# y := 3 ;;
- : unit = ()
# !x ;;
- : int = 3
```

A reference variable can also store a pointer to a function.
```
# let f_ref = ref (fun x -> x) ;;
val f_ref : ('_weak1 -> '_weak1) ref = {contents = <fun>}
# let f x = x + 1 ;1
val f : int -> int = <fun>
# f_ref := f ;;
- : unit = ()
# !f_ref 5 ;;
- : int = 6
```



VARIANTS
--------

Variants are a data type that represent a number of possibilities. A variant definition has the form: `type t = C1 | ... Cn`. The constructor names must begin with a capital letter.
```
# type day = Mon | Tue | Wed | Thu | Fri | Sat | Sun ;;
type day = Mon | Tue | Wed | Thu | Fri | Sat | Sun
# let d:day = Fri ;;
val d : day = Fri
# [d; Mon] ;;
- : day list = [Fri; Mon]
# let int_of_day d =
  match d with
  | Mon -> 1
  | Tue -> 2
  | Wed -> 3
  | Thu -> 4
  | Fri -> 5
  | Sat -> 6
  | Sun -> 7
  ;;
val int_of_day : day -> int = <fun>
# int_of_day Sun ;;
- : int = 7
```

If the constructor names of two types overlap, then a variable will by default be associated with the most recently defined type. Explicitly state the type of the variable to override this behavior. Overlapping names should generally be avoided.
```
# type a = T | F ;;
type a = T | F
# type b = T | F ;;
type b = T | F
# let x = T ;;
val x : b = T
# let x : a = T ;;
val x : a = T
```

Variants can be used to form algebratic data types (sum and product types). An algebratic type definition has the form: `type t = C1 [of t1] | ... | Cn [of tn]`. The constructors that don't have the optional `[of t]` are treated as constants.
```
# type si = String of string | Int of int | Bool ;;
type si = String of string | Int of int | Bool
# let x = Bool ;;
val x : si = Bool
# let y = String "hello" ;;
val y : si = String "hello"
```

Algebraic data types can represent arbitrarily complex data structures.
```
# type point = int * int ;;
type point = int * int
# type shape =
  | Point  of point
  | Circle of point * float
  | Rect   of point * point
  ;;
type shape = Point of point | Circle of point * float | Rect of point * point
# let center = function
  | Point p -> p
  | Circle (p, _) -> p
  | Rect ((x1, y1), (x2, y2)) -> ((x2 +. x1) /. 2.0, (y2 +. y1) /. 2.0)
```

Variant types can be parametrized, such as to provide a type that can represent any data type--also called parametric polymorphism.
```
# type 'a mylist = Nil | Cons of 'a * 'a mylist ;;
type 'a mylist = Nil | Cons of 'a * 'a mylist
# let int_list = Cons (3, Nil) ;;
val int_list : int mylist = Cons (3, Nil)
# let str_list = Cons ("hello", Nil) ;;
val str_list : string mylist = Cons ("hello", Nil)
```

Use parenthesis ("()") to define parametrized types with multiple parameters.
```
# type ('a, 'b) pair = { first : 'a; second : 'b } ;;
type ('a, 'b) pair = { first : 'a; second : 'b; }
# let x = { first = 3; second = "hello" } ;;
val x : (int, string) pair = {first = 3; second = "hello"}
# let y = { first = 1.; second = 2. } ;;
val y : (float, float) pair = {first = 1.; second = 2.}
```

Variants types can be recursive. For example, the built-in `list` data type is defined as: `type 'a list = [] | :: of 'a * 'a list`.
```
# type 'a tree = Leaf | Node of 'a tree * 'a * 'a tree ;;
type 'a tree = Leaf | Node of 'a tree * 'a * 'a tree
# let t = Node(Leaf, 5, Node(Leaf, 8, Leaf)) ;;
val t : int tree = Node (Leaf, 5, Node (Leaf, 8, Leaf))
```

Similar to functions, the "and" keyword allows you to define mutually recursive types.
```
# type node = { value : int; next : mylist }
  and mylist = Nil | Node of node ;;
type node = { value : int; next : mylist; }
and mylist = Nil | Node of node
```

A polymorphic variants acts similar to an anonymous / lambda function, but for a variant. Polymorphic variants types don't have to be declared before they are used, and have no name. Polymorphic variant types are local to their scope, which is useful when you don't expect to reuse a type in your program. The constructor of a polymorphic variant must start with the back tick character ("`").
```
# let f = function
  | 0 -> `Infinity
  | 1 -> `Finite 1
  | n -> `Finite (-n)
  ;;
val f : int -> [> `Finite of int | `Infinity ] = <fun>
# f 5 ;;
- : [> `Finite of int | `Infinity ] = `Finite (-5)
# f 0 ;;
- : [> `Finite of int | `Infinity ] = `Infinity
```



ARRAYS
------

Arrays are a fixed-length mutable data structure that store a list of elements of the same type. Arrays are more memory efficient than lists, and provide constant-time access and update operations.

To define an array, enclose the array elements inside `[|` and `|]`. Array elements are accessed using the dot operator (".") followed by the index inside parenthesis ("()"). Arrays are zero indexed. To assign to an array, use the syntax: `a.(i) <- v`.
```
# let a = [| 1; 2; 3 |] ;;
val a : int array = [|1; 2; 3|]
# a.(0) ;;
- : int = 1
Exception: Invalid_argument "index out of bounds".
# a.(2) <- 4 ;;
- : unit = ()
# a ;;
- : int array = [|1; 2; 4|]
# a.(3) ;;
```




CONDITIONALS
------------

If expressions have the syntax: `if e1 then e2 else e3`. If-else expressions can be placed inside another expressions.
```
# if true then 1 else 2 ;;
- : int = 1
# if 1 > 2 then 1 else 2 ;;
- : int = 2
# 1 + (if 'a' = 'b' then 0 else 5) ;;
- : int = 6
```

To nest multiple if-else expressions, append another `if` condition after the `else` condition.
```
if e1 then e2
else if e3 then e4
...
else en

# if false then 1 else if true then 2 else 3 ;;
- : int = 2
```



PATTERN MATCHING
----------------

Pattern matching involes matching a value against one of a number of options. OCaml supports pattern matching against the following forms:

`_`
: Wildcard pattern, matches any value.

`c`
: Constant match (`5`, `"hello"`, `true`).

`p as v`
: Pattern as value match.

`p when e`
: Match `p` when `e` evaluates to `true`.

`(p)`
: Pattern match.

`(p : t)`
: Explicit type annotation match.

`C p`
: Constructor pattern match.

`t p`
: Polymorphic variant match.

`p1 | ... | pn`
: "Or" pattern. Matches if one of the patterns matches.

`Some p` or `None`
: Optional value match. Defined as: `type 'a option = None | Some of 'a`.

`[]`
: Empty list.

`p :: p`
: List match.

`[ p [; p] ]`
: List match.

`p1, ..., pn` or `(p1, ..., pn)`
: Tuple match.

`{f1 = p1; ...; fn = pn}`
: Record pattern matching.

`#t`
: Type constraint match.

`'c'..'c'`
: Character literal range match (`'A'..'Z'`)

`exception p`
: Exception match.



You can use either the "match" or "function" keyword to perform pattern matching. The "function" keyword automatically pattern matches the last argument. Patterns are separated by the vertical bar character ("|"). The bar before the first pattern is optional. The pattern cases can be written on a single line, or across multiple lines.
```
# let is_zero x =
    match x with
    | 0 -> true
    | _ -> false
  ;;
val is_zero : int -> bool = <fun>
# is_zero 0 ;;
- : bool = true

# let is_zero x = function
      0 -> true
    | _ -> false
  ;;
val is_zero : int -> bool = <fun>
```

The underscore ("_") stands for the wildcard pattern--it matches anything. To avoid future bugs, try to limit the use of the wildcard pattern to when you want to discard a value or know that a certain range will always be covered by the wildcare. Otherwise, explicitly list out all the options.
```
# let is_pos x = match x with x when x > 0 -> 1 | _ -> 0 ;;
val is_pos : int -> int = <fun>
```

Pattern matching can be directly embedded into a functions arguments.
```
# let fst (x, _) = x ;;
val fst : 'a * 'b -> 'a = <fun>
# fst (1, 2) ;;
- : int = 1
# let snd (_, y) = y ;;
val snd : 'a * 'b -> 'b = <fun>
# snd (1, 2) ;;
- : int = 2
```

The OCaml compiler / interpreter will warn you when your pattern match is non-exhaustive, or when an earlier pattern overshadows latter patterns.
```
# let l [] = -1 ;;
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_
val l : 'a list -> int = <fun>

# let l x =
    match x with
    | _ -> x
    | 1 -> 0
  ;;
Warning 11: this match case is unused.
val l : int -> int = <fun>
```

Pattern matching of list types uses "[]" as the base case, and the "::" cons operator for the recursive case.
```
# let rec sum l =
  match l with
  | [] -> 0
  | h :: t -> h + sum t
  ;;
val sum : int list -> int = <fun>
# sum [1; 2; 3] ;;
- : int = 6
```

The `p when e` pattern matches `p` when `e` evaluate to true.
```
# let abs x =
    match x with
    | x when x < 0 -> -x
    | _ -> x
  ;;
val abs : int -> int = <fun>
# abs (-5) ;;
- : int = 5
```

The `Some p` and `None` patterns are used for optional data type matching.
```
# let exist x =
  match x with
    | Some x -> x
    | None -> -1
  ;;
val exist : int option -> int = <fun>
# exist (Some 5) ;;
- : int = 5
# exist None ;;
- : int = -1
```


LOOPS
-----

OCaml supports traditional `for` and `while` loops.

A `for` loop has the syntax: `for e1 to e2 do ... done`.
```
# let a = [| 1; 2; 3 |] ;;
val a : int array = [|1; 2; 3|]
# for i = 0 to (Array.length a) - 1 do
    a.(i) <- a.(i) + 5
  done
  ;;
- : unit = ()
# a ;;
- : int array = [|6; 7; 8|]
```

A `while` loop has the syntax: `while e do ... done`.
```
# let x = ref 0 in
  while !x != 10 do
    x := !x + 1;
    print_int !x
  done
  ;;
12345678910- : unit = ()
```



EXCEPTIONS / ERRORS
-------------------

The `assert` expression evalutates to the unit value `()` if the expression is `true`, and raises and exception is the result is `false`.
```
# assert true ;;
- : unit = ()
# assert (1 * 1 > 2) ;;
Exception: Assert_failure ("//toplevel//", 1, 0)
```

The "exception" keyword allows you to define your own exception type. An `exception` constructor has the form: `exception E [of t]`. The `[of t]` part of the constructor is optional.
```
# exception Returnval of int ;;
exception Returnval of int
# Returnval (-1) ;;
- : exn = Returnval (-1)
```

The "raise" keyword raises an exception value. It has the syntax: `raise e`.
```
# raise Stack_overflow ;;
Stack overflow during evaluation (looping recursion?).
# raise (Sys_error "could not find file") ;;
Exception: Sys_error "could not find file".
```

It is also possible to raise an exception from the `stdlib` library.
```
# let div x y = if (y = 0) then invalid_arg "divisor" else x / y ;;
val div : int -> int -> int = <fun>
# div 5 0 ;;
Exception: Invalid_argument "divisor".
# div 5 2 ;;
- : int = 2
```

The `failwith` function raises an exception of type `Failure`. Calling `failwith s` is equivalent to `raise (Failure s)`.
```
# let head l = if (l = []) then failwith "empty list" else List.hd l ;;
val head : 'a list -> 'a = <fun>
# head [] ;;
Exception: Failure "empty list".
```

The "try" construct is used to catch an exception. This construct has the form: `try e with p1 -> e1 | ... | pn -> en`. If the expression `e` evaluated to one of the patterns, then it is evaluated to the corresponding expressions, else it is simply evaluated.
```
# try 5 / 0 with
  | Division_by_zero -> -1
  | Out_of_memory -> 0
  ;;
- : int = -1
try 25 / 3 with
  | Division_by_zero -> -1
  | Out_of_memory -> 0
  ;;
- : int = 8
```

The "try" construct can be combined with the "match" construct to control the behavior if and if not and exception is raised.



TESTING
-------

The `OUnit` library is the most widely used OCaml testing framework. By convention, test filenames should have the form: "filename_test.ml".
```
open OUnit2
open Filename

let make_sum_test name expected_output input =
  name >:: (fun _ -> assert_equal expected_output (sum input) ~printer:string_of_int)

let tests = "test suite for sum" >::: [
  make_sum_test "empty" 0 [];
  make_sum_test "one" 1 [1];
  make_sum_test "onetwo" 3 [1; 2];
]

let _ = run_test_tt_main tests

$ ocamlbuild -pkgs oUnit filename_test.byte
$ ./filename_test.byte
```



DEBUGGING
---------

OCaml provides a debugging tool called `ocamldebug`.

Use functions with no arguments to interleave debugging print statements.
```
let inc x = let () = print_int(x) in x + 1 ;;
```

The `#trace` directive prints the stack trace of a function. The `#untrace` directive stops the `#trace` directive.



MODULES
-------

Modules are a way of providing a uniform interface / namespace that can be accessed by other parts of a program. Modules abstract away the implementation details.

Module names must begin with a capital letter.

Modules are defined using the "module" keyword. A module definition has the syntax: `module ModuleName = struct ... end`. A module definition can contain `type` definitions, `exception` definitions, `let` definitions, `open` statements, and other `module` definitions.
```
(* [MyStack] implementation of the [Stack] interface. *)
module MyStack : Stack = struct
  type 'a t = Empty | Entry of 'a * 'a t

  let empty = Empty

  let is_empty s = s = Empty

  let push x s = Entry (x, s)

  let peek = function Empty -> failwith "Empty" | Entry (x, _) -> x

  let pop = function Empty -> failwith "Empty" | Entry (_, s) -> s
end
```

Everything inside the `struct` construct must be referenced using a qualified name `ModuleName.x`, unless the module was opened by with a call to `open`.
```
# module M = struct let x = 5 end ;;
module M : sig val x : int end
# M.x ;;
- : int = 5
# x ;;
Error: Unbound value x
# open M ;;
# x ;;
- : int = 42
```

If two modules define the same name, then the latest definition has priority over the older definition. Use the dot operator (".") to deal with duplicate names.
```
# module M = struct let x = 5 end ;;
module M : sig val x : int end
# module N = struct let x = "hello" end ;;
module N : sig val x : string end
# open M ;;
# open N ;;
# x ;;
- : string = "hello"
# M.x ;;
- : int = 5
```

Because of namespace conflicts, global calls to `open` should be kept to a minimum. Instead, there are ways to open a module in a local scope. The syntax for opening a module in a local scope is: `let open M in e`. A more concise syntax with the same effect is: `M.(e)`.
```
# let f x = let open List in filter (( < ) 0) (map (( + ) 5) x) ;;
val f : int list -> int list = <fun>
# f [ ~-6; ~-5; 0; 5; 6 ] ;;
- : int list = [5; 10; 11]

# let f x = List.(filter (( < ) 0) (map (( + ) 5) x)) ;;
val f : int list -> int list = <fun>
```

A module type describes groups of related modules. Module type names are usually capitalized. A module type definition has the form: `module type ModuleTypeName = sig ... declarations ... end`. The declarations section contains the signature of the module type. The signature is a sequence of type declarations for the components of a module. The syntax for a type declaration is: `val id : t`.
```
(* [Stack] module interface *)
module type Stack = sig
  type 'a t

  val empty : 'a t

  val is_empty : 'a t -> bool

  val push : 'a -> 'a t -> 'a t

  val peek : 'a t -> 'a

  val pop : 'a t -> 'a t
end
```

A structure matches a signature if it contains definitions for all of the names in the signature and all of the type requirements match.
```
module type Sig = sig
  val f : int -> int
end

module M1 : Sig = struct
  let f x = x + 1
end

module M2 : Sig = struct
  let f x = x
end
```

A module that implements a module type must specify the concrete types for the abstract types and define all the names declared in the signature. A module implementation has the form: `module ImplementationName : ModuleName = struct ... end`. In OCaml, it is considered good practice to name the representation type of a data structure as `t` to reduce the verbosity of names (e.g. `'a t` instead of `'a stack`).
```
module ListStack : Stack = struct
  type 'a stack = 'a list

  let empty = []

  let is_empty s = s = []

  let push x s = x :: s

  let peek = function [] -> failwith "Empty" | x :: _ -> x

  let pop = function [] -> failwith "Empty" | _ :: xs -> xs
end

# ListStack.push 1 ListStack.empty ;;
- : int ListStack.stack = <abstr>
```

Writing `module M = struct` instead of `module M : MN` removes the abstraction of the implementation. The `M1` module below does not abstract its implementation to the caller.
```
# module type Sig = sig
  type t

  val init : t
end

module M1 = struct
  type t = int

  let init = 5
end

module M2 : Sig = struct
  type t = int

  let init = 5
end
;;
module type Sig = sig type t val init : t end
module M1 : sig type t = int val init : t end
module M2 : Sig
# M1.init ;;
- : int = 5
# M2.init ;;
- : M2.t = <abstr>
```

A sharing constraint allows a module to expose its implementation type to the caller. A sharing contraint for the `int` data type has the form: `T with type t = int`. For example: `module Ints : (Arith with type t = int) = struct ... end`.

A compilation unit consists of a ".ml" implementation file and a ".mli" interface file. The two files share the same base name (e.g. "x.ml" and "x.mli").
```
$ cat x.mli
val x : int
val f : int -> int -> int
$ cat x.ml
let x = 0
let y = 12
let f x y = x + y
```

The "include" keyword allows a structure to reuse code from another structure or a signature to reuse code from another signature. Including a structure is like copying all the definitions from one structure to another. The type annotation can be manipulated to control the visibility of the implementation.
```
module type SetExtended = sig
  include Set

  val of_list : 'a list -> 'a t
end

module ListSetDupsExtended : SetExtended = struct
  include ListSetDupsImpl

  let of_list lst = lst
end
```

Contrary to the `open` command, the `include` keyword makes all of the definitions available internally as well as externally. The `open` command only makes the definitions available for the scope of the enclosing structure--it doesn't export them.
```
# module M = struct
  let x = 0
end

module N = struct
  include M
end

module O = struct
  open M
end
;;
module M : sig val x : int end
module N : sig val x : int end
module O : sig  end
```

Compiling module files creates a ".cmo" compiled module object file. The `#load` toplevel command loads a compiled module object file and makes it avilable in the interpreter session. The `#use` command directly loads the textual contents of a file into the session.



FUNCTORS
--------

A functor is a mapping from a structure to another structure. In OCaml, a functor is written as a parametrized module. The syntax for creating a functor is: `module F (M1 : S1) ... (Mn : Sn) = struct ... end`. Equivalently, a functor definition can also be written with the anonymous functor syntax: `module F = functor (M1 : S1) -> ... -> functor (Mn : Sn) -> struct ... end`. Similar to the "fun" keyword for anonymous functions, the "functor" keyword creates an anonymous functor.

To type annotate a functor use the syntax: `module F (M : Si) : So = struct ... end`; or `module F (M : Si) = (struct ... end : So)`. The syntax for the type interface of a functor is similar to functions: `functor (M : Si) -> So`.

The `IncX` function takes in a module parameter, and increments its `x` field. A functor doesn't necessarily have to change the module passed in as an argument--it can simply ignore it.
```
# module type X = sig
  val x : int
end

module IncX (M : X) = struct
  let x = M.x + 1
end

module SetY (M : X) = struct
  let y = 5
end
;;
module type X = sig val x : int end
module IncX : functor (M : X) -> sig val x : int end
module SetY : functor (M : X) -> sig val y : int end

# module A = struct let x = 0 end ;;
module A : sig val x : int end
# A.x ;;
- : int = 0
# module B = IncX(A) ;;
module B : sig val x : int end
# B.x ;;
- : int = 1
# module C = IncX(B) ;;
module C : sig val x : int end
# C.x ;;
- : int = 2
# module D = IncX(A) ;;
module D : sig val x : int end
# D.x ;;
- : int = 1

# module E = SetY(A) ;;
module E : sig val y : int end
# E.x ;;
Line 1, characters 0-3:
Error: Unbound value E.x
# E.y ;;
- : int = 5
```



SPECIFICATIONS
--------------

A specification is a contract between the user and the implementer of some code. It serves as an abstraction barrier between the client and the implementer. The specification specifies what the client can assume about the module's behaivor. It describes which preconditions and postconditions are guaranteed to be met.

Specifications are usually written in the ".mli" interface file. These types of specifications should be written for other implementers or maintainers of the module.
```
(** [sqr x] is the square root of [x], with relative accuracy no worse
    than 1.0x10^-6. Raises: [Negative] if [x < 0]. *)
let sqr x = ...

(** [find lst x] is the index of [x] in [lst], starting from zero.
    Example: [find ["b","a","c"] "a" = 1]. *)
let lst x = ...
```



STANDARD LIBRARY
----------------

Examples of modules in the standard library:
- `Arg`: Command line argument parsing.
- `Array`: Array operations.
- `Bool`: Boolean values.
- `Buffer`: Buffer operations.
- `Bytes`: Byte sequences.
- `Char`: Character operations.
- `Complex`: Complex numbers.
- `Filename`: Filename operations.
- `Float`: Floating point values.
- `Hashtbl`: Hash tables.
- `Int`: Integers.
- `Int32`: 32-bit integers.
- `Int64`: 64-bit integers.
- `Lazy`: Lazy / deferred operations.
- `Lexing`: Lexers.
- `List`: List operations.
- `Map`: Association tables.
- `Marshal`: Marshaling of data structures.
- `Nativeint`: Processsor-native integers.
- `Option`: Option values.
- `Parsing`: Parsing functionality.
- `Printf`: Formatted printing.
- `Queue`: FIFO queues.
- `Random`: Pseudo-random number generation.
- `Scanf`: Formatted input.
- `Seq`: Iterators.
- `Set`: Set over ordered types.
- `Spacetime`: Memory profiler.
- `Stack`: LIFO stacks.
- `Stdlib`: Standard library. All the functions in `Stdlib` can be called without having to prefix `Stdlib`.
- `Stream`: Streams and parsers.
- `String`: String operations.
- `Sys`: System interface.
- `Uchar`: Unicode characters.
- `Unit`: Unit values.




Src: [^clarkson] [^leroy] [^minsky]

[^clarkson]: Clarkson, M. (2020). Functional Programming in OCaml. Retrieved from https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/

[^leroy]: Leroy, X. (2020). The OCaml system release 4.10. Retrieved from https://ocaml.org/releases/4.10/htmlman/

[^minsky]: Minsky, Y., Madhavapeddy, A., & Hickey, J. (2013). Real World OCaml: Functional programming for the masses. " O'Reilly Media, Inc.".
